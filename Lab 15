
贪吃蛇博客介绍
贪吃蛇游戏需要的元素
1.地图2.蛇3.食物4.边界5.游戏进行状况
往下细分
地图包含
1.绘制地图、2.地图大小、3.更新地图
蛇包含：
蛇的长度，蛇头和蛇尾的方向，蛇的操控模式
3.食物包含：
1.食物的位置，食物的数量，食物的出现方式
4.边界：
边界长度，边界的大小，边界游戏状况，撞到边界以后退出游戏或是其他的惩罚
5.游戏的进行状况
游戏的操控方法，游戏是否会崩溃。
开始函数
我们需要先写下开始游戏的函数
Void Gamestart（）
之后是游戏地图生成的函数：
绘制地图可以生成空白地图，也可以导入地图，我们选择先生成空白地图，之后的边界是两边都有的，然后将贪吃蛇放在最左边的一行，为了用户能够自定义程序，  
用户在开始前可以输入地图规模和贪吃蛇的初始长度（初始长度不能超过地图边界的长度）。蛇的头是’H’，蛇的身体是’X’，地图边界是’*’，食物格子是’$’。
蛇的移动
首先实现蛇的移动，我们需要几个函数，分别是isOutOfBound判断是否出界，isSnakeself判断是否是蛇本身，isFood判断是否是食物格子。   
（这里我们要用getchar来实现键盘的输入，也可是keyboard输入函数）
然后我们考虑蛇移动一格的情况。不难发现，蛇移动一格，相当于多出来头移动到的一格，少掉尾巴的一格（当然可以有其他的想法，不过这么做应该是最方便实现的）。  
当然我们还需要维护一个序列（数组）表示蛇身子各个格子的坐标，这样我们才可以知道哪里是蛇的尾巴和头。然后注意到原来蛇的头要恢复成’X’（前提是蛇的长度长于2）。这  
样的设计有助于程序的维护
生成食物
生成食物挺简单的，一般的做法是每次随机一个坐标
(x,y)
然后判断map【x】,[y]是不是随机函数，这个地方有没有食物空间，如果有就可以
也可用<Time.h>来随机生成，种下时间种子之后使用random函数
(x,y)
只要生成到可以放就好了，不会有太大的问题（毕竟蛇超过地图格子数一半基本就很容易GameOver） 
为了防止出现游戏越到后期食物的格子越少，便利复杂度更高的情况，那么这套方案就容易陷入很多次的循环，导致程序运行缓慢。我们需要一个序列来存取我们的程序，   
如果少了格子就从序列中删去，如果怕没有少就从序列中添加。我们需要每次修改地图的时候都维护一下，因此之前我们的实现可能是map[x][y] = newchar;，  
我们修改成updateMap(int x, int y, char newchar)，在updateMap函数中维护序列即可，同时这样我们也加强了程序的可维护性，我们如果视情况修改地图，  
只需要简单地修改一下updateMap函数即可。最后我们只需要从空白格子的序列中随机一个格子放食物即可，这样就可以避免空白格子比例太小导致循环过多次的问题。  
（当然也加大的程序实现的复杂度）
吃食物
既然我们生成了食物，我们要需要蛇吃食物。注意到如果蛇吃了食物，相当于尾巴的一格不删去，头多一个（和蛇整体向前移动一格，尾巴多出来效果一样）。  
注意到这一点我们的代码就好写多了。然后再重新生成食物即可。同时我们还可以判断是否游戏胜利，因为游戏胜利只会在蛇吃到食物的瞬间发生（最后一格的食物被吃到）。  

不再闪烁的屏幕
实现完程序后，会发现每次蛇移动后重新生成地图，刷新控制台并重新输出地图会造成屏幕的闪烁（这可能是因为控制台更新屏幕的延迟较高？速度较慢？），  
这对游戏造成很大的视觉影响，虽然每次重新输出地图代码十分地好写，但我们为了用户着想，我们应该改成每次只更新屏幕上需要更新的地方（即更新地图变化的位置），  
参考updateMap函数。经过资料查阅，我们可以知道在Windows下的修改光标位置的方法，请参见程序的setCursor函数，调用了Windows API：  
SetConsoleCursorPosition。（光标有助于修复地图）
蛇的自动前进
至此我们实现了按一次按键蛇动一次的程序，但是我们见过的一般的贪吃蛇游戏都是控制蛇的运动方向，而蛇自行定时按照方向移动一格。为了实现这个程序，  
我们需要让程序每500毫秒才响应一次键盘按键。经过查阅，知道了暂停程序的函数为Sleep(milliseconds)，请参见程序中的两个sleepProgram函数。  
然后我们每次循环都暂停500ms，然后再不阻塞地获取键盘按键（原来实现的原理是getch函数会阻塞程序运行，也就是如果我们不按下键盘按键，  
getch函数就会一直运行，当然实现的结果与while(if not any key pressed) wait for a short while;这种类似，  
当然系统有更好的实现方法减轻CPU的负担）。这样我们就可以做到蛇的自动前进。
